# Chat History Feature Specification ## Overview Implement a message history system that stores and retrieves all user-AI conversations based on `current_user.id` in the `/support/chatkit` endpoint. ## Database Schema ### New Table: `ChatMessage` ```python class ChatMessage(SQLModel, table=True): __tablename__ = "chat_message" id: Optional[str] = Field(default=None, primary_key=True) userId: str = Field(foreign_key="user.id", index=True) role: str # "user" or "assistant" content: str createdAt: datetime = Field(default_factory=lambda: datetime.now(timezone.utc)) user: Optional[User] = Relationship(back_populates="chat_messages") ``` ### Update User Model ```python class User(SQLModel, table=True): # ... existing fields ... chat_messages: List["ChatMessage"] = Relationship(back_populates="user") ``` ## Implementation Flow ### 1. Message Storage Process **When user sends a message:** 1. Extract user input from request 2. Create `ChatMessage` record: - `userId`: `current_user.id` - `role`: `"user"` - `content`: user's query/message 3. Save to database **When AI responds:** 1. Get AI's response/output 2. Create `ChatMessage` record: - `userId`: `current_user.id` - `role`: `"assistant"` - `content`: AI's response 3. Save to database ### 2. Message Retrieval Process **Before processing new message:** 1. Query all previous messages for `current_user.id`: ```python messages = db.query(ChatMessage).filter( ChatMessage.userId == current_user.id ).order_by(ChatMessage.createdAt.asc()).all() ``` 2. Format message history for AI: ```python history = [ {"role": msg.role, "content": msg.content} for msg in messages ] ``` 3. Pass full history to AI along with new message ### 3. Code Location **File:** `backend/app/main.py` **Route:** `POST /support/chatkit` **Modifications Required:** ```python @app.post("/support/chatkit") async def chatkit_endpoint( request: Request, server: CustomerSupportServer = Depends(get_server), current_user: User = Depends(get_current_user), db: SQLSession = Depends(get_session) ) -> Response: # 1. Retrieve chat history chat_history = db.query(ChatMessage).filter( ChatMessage.userId == current_user.id ).order_by(ChatMessage.createdAt.asc()).all() # 2. Get user input from request payload = await request.body() # Extract user message from payload # 3. Save user message user_message = ChatMessage( id=generate_unique_id(), userId=current_user.id, role="user", content=user_input_text ) db.add(user_message) db.commit() # 4. Pass history + new message to AI formatted_history = [ {"role": msg.role, "content": msg.content} for msg in chat_history ] # 5. Process with AI (include history in context) result = await server.process( payload, { "request": request, "chat_history": formatted_history } ) # 6. Extract AI response and save # (This happens after streaming/response generation) assistant_message = ChatMessage( id=generate_unique_id(), userId=current_user.id, role="assistant", content=ai_response_text ) db.add(assistant_message) db.commit() return result ``` ## Key Features 1. **Per-User History**: Each user's messages stored separately using `userId` 2. **Chronological Order**: Messages retrieved in order of creation (`createdAt`) 3. **Full Context**: AI receives complete conversation history on every request 4. **Role-Based**: Clear distinction between user and assistant messages 5. **Persistent**: All conversations saved to database ## Database Migration ```sql CREATE TABLE chat_message ( id TEXT PRIMARY KEY, "userId" TEXT NOT NULL, role TEXT NOT NULL, content TEXT NOT NULL, "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP, CONSTRAINT chat_message_userId_fkey FOREIGN KEY ("userId") REFERENCES "user"(id) ON DELETE CASCADE ); CREATE INDEX idx_chat_message_userId ON chat_message("userId"); CREATE INDEX idx_chat_message_createdAt ON chat_message("createdAt"); ``` ## Benefits - ✅ Complete conversation context for AI - ✅ User-specific chat history - ✅ No data mixing between users - ✅ Easy to retrieve and display chat history - ✅ Scalable architecture